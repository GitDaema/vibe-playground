import type { Rule, Condition, Action, RuleSet } from './rule-engine/types';

// ?¤ë¥˜ ?•ë³´ë¥??´ëŠ” ?´ë˜??export class CnlParsingError extends Error {
  public line: number;
  constructor(message: string, line: number) {
    super(`[Line ${line}] ${message}`);
    this.name = 'CnlParsingError';
    this.line = line;
  }
}

// CNL??ê°???clause)???Œì‹±?˜ëŠ” ?œí”Œë¦?interface ClauseTemplate {
  regex: RegExp;
  type: 'when' | 'then';
  factory: (match: RegExpMatchArray) => Condition | Action;
}

// ì§€?í•  CNL ?¨í„´ ?•ì˜
const CLAUSE_PATTERNS: ClauseTemplate[] = [
  // ì¡°ê±´ (when)
  {
    regex: /(.+?)??(?:?„ì°©?˜ë©´|?ˆìœ¼ë©?/,
    type: 'when',
    factory: (m) => ({ at: m[1].trim() }),
  },
  {
    regex: /(.+?)ë¥?ê°€ì§€ê³??ˆìœ¼ë©?,
    type: 'when',
    factory: (m) => ({ has: m[1].trim() }),
  },
  // ?‰ë™ (then)
  {
    regex: /(.+?)(?:ë¡??¼ë¡œ) ?´ë™(?:?œë‹¤)?/,
    type: 'then',
    factory: (m) => ({ moveTo: m[1].trim() }),
  },
  {
    regex: /(.+?)ë¥?(?:ì¤ëŠ”???»ëŠ”??/,
    type: 'then',
    factory: (m) => ({ pickup: m[1].trim() }),
  },
  {
    regex: /(.+?)ë¥?(?:?¬ìš©?œë‹¤|ë²„ë¦°??/,
    type: 'then',
    factory: (m) => ({ drop: m[1].trim() }),
  },
  // ?½ì‹ ?œí˜„ (Shorthand)
  {
    regex: /?´ë™\s*??s*(.+)/,
    type: 'then',
    factory: (m) => ({ moveTo: m[1].trim() }),
  },
];

/**
 * ?œì–´???ì—°??CNL) ?ìŠ¤?¸ë? ?Œì‹±?˜ì—¬ ê·œì¹™ ?¸íŠ¸(RuleSet) JSON?¼ë¡œ ë³€?˜í•©?ˆë‹¤.
 * @param cnlText ?¬ìš©?ê? ?…ë ¥???¬ëŸ¬ ì¤„ì˜ CNL
 * @returns ?Œì‹±??ê·œì¹™ ?¸íŠ¸?€ ë°œìƒ???¤ë¥˜ ëª©ë¡
 */
export function parseCnl(cnlText: string): { rules: RuleSet; errors: CnlParsingError[] } {
  const lines = cnlText.split('\n').filter(line => line.trim() !== '');
  const rules: RuleSet = [];
  const errors: CnlParsingError[] = [];

  lines.forEach((line, index) => {
    const lineNumber = index + 1;
    try {
      // ì£¼ì„?€ ë¬´ì‹œ
      if (line.trim().startsWith('#')) {
        return;
      }
      
      const rule: Rule = {
        when: [],
        then: [],
        sourceLine: lineNumber,
      };

      // "A?˜ë©´, B?˜ê³ , C?œë‹¤" -> ["A?˜ë©´", "B?˜ê³ ", "C?œë‹¤"]
      const clauses = line.split(/,/).map(s => s.trim());
      let thenClauseFound = false;

      for (const clause of clauses) {
        let matched = false;
        for (const pattern of CLAUSE_PATTERNS) {
          const match = clause.match(pattern.regex);
          if (match) {
            const part = pattern.factory(match);
            if (pattern.type === 'when') {
              if (thenClauseFound) {
                throw new CnlParsingError('ì¡°ê±´?ˆì? ?‰ë™???¤ì— ?????†ìŠµ?ˆë‹¤.', lineNumber);
              }
              rule.when.push(part as Condition);
            } else {
              thenClauseFound = true;
              rule.then.push(part as Action);
            }
            matched = true;
            break;
          }
        }
        if (!matched) {
          throw new CnlParsingError(`'${clause}' ?ˆì„ ?´ì„?????†ìŠµ?ˆë‹¤.`, lineNumber);
        }
      }

      if (rule.then.length === 0) {
        throw new CnlParsingError('ê·œì¹™???‰ë™(then)???†ìŠµ?ˆë‹¤.', lineNumber);
      }
      
      // ì¡°ê±´???†ëŠ” ê²½ìš°, ??ƒ ì°¸ì¸ ì¡°ê±´ ì¶”ê? (?”ì‹œ??
      if (rule.when.length === 0) {
        rule.when.push({ always: true });
      }

      rules.push(rule);
    } catch (e) {
      if (e instanceof CnlParsingError) {
        errors.push(e);
      } else {
        errors.push(new CnlParsingError('?????†ëŠ” ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.', lineNumber));
      }
    }
  });

  return { rules, errors };
}
